package triggers

// Code generated by the Komand Go SDK Generator. DO NOT EDIT

import (
    plog "github.com/rapid7/komand-plugin-sdk-go2/log"
    "github.com/rapid7/komand-plugin-sdk-go2/dispatcher"
    "github.com/rapid7/komand-plugin-sdk-go2/message"

    "{{ .PackageRoot }}/connection"
)

// {{ .Name}}TriggerCustomLooper is an interface you can implement to override RunLoop behavior
type {{ .Name}}TriggerCustomLooper interface {
	RunLoopCustom(ctx context.Context, conn *connection.Connection, input *{{ .Name }}TriggerInput, log plog.Logger) error
}

{{ $name := .Name }}
{{- range $n, $p := .Input }}
{{- if $p.EnumLiteral }}
{{- range $i, $e := $p.EnumLiteral }}
// {{ $name }}TriggerInput{{ $e.Name }} is an enumerated value
const {{ $name}}TriggerInput{{ $e.Name }} = {{ $e.LiteralValue }}
{{- end }}
{{- end }}
{{- end }}
{{- range $n, $p := .Output }}
{{- if $p.EnumLiteral }}
// Output Enums
{{- range $i, $e := $p.EnumLiteral }}
// {{ $name}}TriggerOutput{{ $e.Name }} is an enumerated value
const {{ $name }}TriggerOutput{{ $e.Name }} = {{ $e.LiteralValue }}
{{- end }}
{{- end }}
{{- end }}

// {{ .Name}}TriggerInput defines the input for the {{ .Name }}Trigger
type {{ .Name }}TriggerInput struct {
    Custom{{ .Name }}TriggerInputParams

    {{- range $n , $p := .Input}}
    {{ $p.Name }} {{ $p.Type }} `json:"{{ $p.RawName }}"`
    {{- end }}
}

// {{ .Name}}TriggerOutput defines the output for the {{ .Name}}Trigger
type {{ .Name }}TriggerOutput struct {
    {{- range $n , $p := .Output }}
    {{ $p.Name }} {{ $p.Type }} `json:"{{ $p.RawName }}"`
    {{- end }}
}

// {{ .Name }}Trigger a trigger
type {{ .Name }}Trigger struct {
    queue chan *{{ .Name }}TriggerOutput
    dispatcher dispatcher.Dispatcher
    meta message.TriggerEventMeta
}

// New{{ .Name }}Trigger returns a new {{.Name }}Trigger properly initialized and ready to run.
func New{{ .Name }}Trigger(d dispatcher.Dispatcher, meta message.TriggerEventMeta) *{{ .Name }}Trigger {
    return &{{ .Name }}Trigger{
        queue: make(chan *{{ .Name }}TriggerOutput, 1),
        dispatcher: d,
        meta: meta,
    }
}

// Send will submit a {{ .Name }}TriggerOutput onto the internal queue, which then buffers to the external queue
func (t *{{ .Name }}Trigger) Send(o interface{}) {
    t.queue <- o.(*{{ .Name}}TriggerOutput)
}

// Stop will close the internal queue, which will prevent new jobs from entering.
func (t *{{ .Name }}Trigger) Stop() {
    close(t.queue)
}

// RunLoop runs the trigger and blocks until the trigger polling is complete or errors. It will block.
// TODO This could be optimized so that the "instant tick" idiom is only used when the ticker is used
// It would take more work but it would be a definite improvement. Also this does mean the first iteration
// of the loop will ignore a cancelletion from the context, but at this time i am willing to accept that tradeoff
// since this helps the more likely case of a message being lost on sudden shutdown.
func (t *{{ .Name }}Trigger) RunLoop(ctx context.Context, conn *connection.Connection, input *{{ .Name}}TriggerInput, log plog.Logger) error {
   // Trigger inputs only get sent in once. Before we event bother with this loop stuff, check it
   // Bail if it's invalid
   var err error
   for _, err = range input.Validate(log) {
        log.Errorf("Error while validating {{ .Name}}TriggerInput: %s\n", err.Error())
   }
   if err != nil {
       return fmt.Errorf("Error while validating {{ .Name}}TriggerInput. Check logs for details")
   }
   // This timer idiom is a bit odd - it is the "instant tick" idiom
    // Basically, i don't need to wait for the first iteration of the timer for it to fire
	// it fires immediately, then every duration thereafter.
	// See: https://www.reddit.com/r/golang/comments/5g0hor/ticker_with_instant_start/daoxqey/
    // You will only see a ticker here if the Trigger defined the "Interval" field, otherwise this is a vanilla for{select{}}
    for {{- if .HasInterval }} tick := time.NewTicker(time.Second * time.Duration(input.Interval)); ;{{- end }}{
        output, err := t.Run(conn, input, log)
        if err != nil {
            log.Errorf("Error while running trigger action for {{ .Name }}Trigger: %s\n", err.Error())
            continue
        }
        t.Send(output) // Leave this untouched line, it will submit the trigger output to the Komand system.

        select {
        case <-ctx.Done():
            return ctx.Err()
        {{- if .HasInterval}}
        case <- tick.C:
            // When it ticks, loop back to the top
            continue
        {{- end}}
        {{- if not .HasInterval}}
        default:
            // Loop back to the top, polling and submitting another message
            continue
        {{- end}}
        }
    }
}

// ReadLoop will block, reading until a nil message is received, meaning the internal queue was closed
func (t *{{ .Name }}Trigger) ReadLoop(ctx context.Context, log plog.Logger) error {
    for {
        select {
        case output := <-t.queue:
            if output == nil {
                // The channel was closed, we got an empty-closed-read, so we bail out with no issues
                return nil
            }
            response := message.TriggerEvent{
                Type: "", // We did not set the type in the SDK before, seems to only be for testing or legacy needs
                ID: "", // We did not set the ID in the SDK before
                GroupID: "", // We did not set the GroupID in the SDK before
                Output: output,
                Meta: t.meta, // Copy the incoming meta to pass it along to the outgoing message
            }
            m := message.V1{
                Version: "v1",
                Type: "trigger_event",
                Body: &response,
            }
            // Send the message to the komand system
		    if err := t.dispatcher.Send(m); err != nil {
			    log.Errorf("Receieved error sending trigger message: %s\n", err)
			    return err
		    }
        case <-ctx.Done():
            // We check this AFTER the queue, because the publish end of this loop needs to stop submitting
            // things to the trigger, then we make sure we've drained that channel, then we can stop.
            // We don't want to quit with a message still in the pipe, lest it be lost. 
            // We're done, bailout
            return ctx.Err()
        }
	}
}